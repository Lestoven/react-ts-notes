import React, { createContext, ReactNode, useContext, useEffect, useReducer, useState } from "react";
import { getNotes } from "../serverRequests/getNotes";
import { Note, NoteCreationData } from "../types/note";

import { saveNote } from "../serverRequests/saveNote";
import { toast, Slide } from 'react-toastify';
import { getCurrentUserID } from "../serverRequests/getCurrentUserID";
import { updateNote } from "../serverRequests/updateNote";

type NotesAction =
    | { type: "set"; payload: Note[] }
    | { type: "create"; payload: Note }
    | { type: "update"; payload: Note }
    | { type: "delete"; payload: { id: number } };

const NotesContext = createContext<{ notes: Note[], isLoading: boolean } | undefined>(undefined);
const NotesDispatchContext = createContext<React.Dispatch<NotesAction> | undefined>(undefined);

const NotesProvider = ({ children }: { children: ReactNode }) => {
    const initialNotes: Note[] = [];

    const [notes, dispatch] = useReducer(notesReducer, initialNotes);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        async function fetchNotes() {
            const notesData: Note[] = await getNotes();
            dispatch({ type: "set", payload: notesData });
            setIsLoading(false);
        };

        fetchNotes();
    }, []); // we have to send a request to the server to get the notes


    return (
        <NotesContext.Provider value={{ notes: notes, isLoading: isLoading }}>
            <NotesDispatchContext.Provider value={dispatch}>
                {children}
            </NotesDispatchContext.Provider>
        </NotesContext.Provider>
    );
};

export function useNotes() {
    return useContext(NotesContext);
};

export function useNotesDispatch() {
    return useContext(NotesDispatchContext);
};

function notesReducer(notes: Note[], action: NotesAction): Note[] {
    switch (action.type) {
        case 'set': {
            return action.payload;
        }
        case 'create': {
            return [action.payload, ...notes];
        }
        case 'update': {
            return notes.map(note => note.id === action.payload.id ? action.payload : note);
        }
        case 'delete': {
            return notes.filter(note => note.id !== action.payload.id);
        }
        default: {
            const _exhaustiveCheck: never = action
            return _exhaustiveCheck;
        }
    };
};

export async function handleNoteSave(newNote: NoteCreationData, dispatch: React.Dispatch<NotesAction>) {
    const noteData = {
        ...newNote,
        id: -Date.now(), // generate temporary id
        dateCreated: new Date(),
        dateUpdated: null,
        owner: getCurrentUserID()
    };

    dispatch({ type: "create", payload: noteData }); // display the new note on the UI (Notes state will be updated causing a re-render)

    try {
        const resultNode = await saveNote(noteData);

        // display success toast message
        toast.success("Note saved successfully!", {
            position: "bottom-center",
            isLoading: false,
            autoClose: 2500,
            transition: Slide,
            closeOnClick: true,
        });
        dispatch({ type: 'update', payload: resultNode }); // Update the new note to have the ID generated by the server.
    } catch (error) {
        // display error toast message
        toast.error("Failed to save note!", {
            position: "bottom-center",
            isLoading: false,
            autoClose: 2500,
            transition: Slide,
            closeOnClick: true,
        });
        dispatch({ type: 'delete', payload: { id: noteData.id } }); // Remove the "new note" from the UI
    }
};

export async function handleNoteUpdate(updatedNote: Note, dispatch: React.Dispatch<NotesAction>) {
    dispatch({
        type: 'update',
        payload: updatedNote
    });

    try {
        await updateNote(updatedNote);
        toast.success("Note updated!", {
            position: "bottom-center",
            isLoading: false,
            autoClose: 2500,
            transition: Slide,
            closeOnClick: true
        });
    } catch(error) {
        // display error toast message
        toast.error("Failed to update node!", {
            position: "bottom-center",
            isLoading: false,
            autoClose: 2500,
            transition: Slide,
            closeOnClick: true
        });
    };
};

export default NotesProvider;